# Documentação Consolidada Final — Hub Kanban Configurável e Integrável (MVP)

## 1) Propósito do sistema

Este sistema é um **Hub Central de Gestão de Atividades** baseado em **Kanban**, criado para centralizar trabalho operacional e gerencial em um único lugar, com estes objetivos:

1. **Transformar ocorrências/objetos de sistemas externos** (telemetria, cobrança, contato, etc.) em **cards** dentro de **boards específicos**.
2. Permitir que um time execute o trabalho com **fluxo visual por colunas**, preenchendo dados de forma estruturada e rastreável.
3. Tornar os cards **configuráveis por tipo** (CardType), com campos dinâmicos e exibição configurável **sem precisar de build** para cada variação de formato.
4. Manter **histórico estruturado** de tudo que aconteceu com cada card.
5. Ser **extensível** via plugins visuais dentro do card (hardcoded no código, mas governados por cadastro no banco).
6. Permitir integrações de saída via **Webhook genérico configurável**, com **template e variáveis**, sem bloquear fluxo quando faltarem dados.

O foco do MVP é entregar um **core de operação sólido**: gestão de módulos/árvore/boards/cards, ingestão de eventos externos, card types configuráveis, histórico, permissões e integração de saída manual.

---

## 2) Para quem é (papéis) e como será usado

### 2.1 Operacional (usuário do dia a dia)

* Abre um board e trabalha cards.
* Vê dados vindos de sistemas externos (readonly).
* Preenche campos do processo (inputs).
* Move cards entre colunas.
* Aplica labels do board.
* Consulta histórico do card.

### 2.2 Gestor/Líder

* Acompanha volume e andamento por coluna.
* Ajuda a ajustar processos (se tiver permissão).
* Pode operar cards e revisar histórico.

### 2.3 Administrador

* Faz cadastros e configurações para o sistema operar:

  * módulos, árvore, boards, colunas, labels
  * CardTypes e seus campos
  * IngressSources (fontes de entrada)
  * catálogo de plugins (registro no banco)
  * conectores de saída (webhook)
  * usuários e permissões

---

## 3) Modelo mental: Módulos → Árvore → Boards → Colunas → Cards

### 3.1 Módulos

O sistema possui **N módulos**, que representam grandes áreas/processos do negócio (ex.: Telemetria, Cobrança, Vistoria, Relacionamento).

### 3.2 Árvore de navegação por módulo

Cada módulo possui uma **árvore com profundidade N**, exibida no lado esquerdo (sidebar).
Essa árvore representa a organização do trabalho (empresa → unidade → processo → board, etc.).

* Nós podem ter filhos.
* Folhas representam o ponto final: um **Board**.

### 3.3 Boards (Kanban)

Um **Board** é o quadro Kanban onde o trabalho acontece.

Regras estruturais:

* Boards têm **colunas configuráveis**.
* Cards são movidos manualmente (drag & drop).
* Cada board é voltado a um **processo específico** (não misturar “coisas aleatórias”).
* **Cada board tem 1 CardType associado**.
* **Todo card é necessariamente de um CardType** (não existe card “sem tipo”).

---

## 4) Jornada do usuário (fluxo de navegação e uso)

### 4.1 Login e tela inicial

1. Usuário faz login.
2. Entra em uma tela inicial com **listagem de módulos**.

   * Usuário comum: vê e entra nos módulos permitidos.
   * Admin: pode criar/editar/remover módulos.

### 4.2 Entrando no módulo

Ao abrir um módulo:

* **esquerda**: árvore de nós (estrutura do módulo)
* **direita**: área principal (conteúdo)

### 4.3 Selecionando um board

Ao clicar em uma **folha** (nó final) da árvore:

* a área da direita carrega o **Kanban do board**.

### 4.4 Operando o Kanban

No board:

* colunas exibem cards paginados (lazy load)
* card mostra preview configurado
* clicar abre o card em modal
* mover cards entre colunas segue o processo

### 4.5 Configurando o board (“engrenagem”)

Dentro do board existe uma **engrenagem** (ou botão equivalente) visível conforme permissão.

Essa engrenagem permite configurar o board no contexto correto (onde ele é usado), incluindo:

* nome/descrição do board
* colunas (CRUD)
* labels do board (CRUD)
* CardType associado ao board
* fonte de entrada (IngressSource) associada ao board
* conector webhook habilitado (se houver botão “ações manuais”)

> Automações não fazem parte do MVP. No MVP2, essa engrenagem também será o lugar natural para configurar automações por board.

---

## 5) Card: unidade de trabalho e dados estruturados

### 5.1 Card fechado (preview)

O card no kanban exibe um conjunto de campos em destaque (preview), configurados no CardType.

### 5.2 Card aberto (modal)

O modal do card deve conter, em seções claras:

* **Dados de Origem (source)**: informação recebida do sistema externo (readonly)
* **Campos do Processo (inputs)**: preenchidos pelo usuário (editáveis)
* **Saídas do Processo (outputs)**: geradas pelo sistema/processo (readonly no MVP)
* **Propriedades (props)**: labels e propriedades gerais do card
* **Plugins** (se o CardType tiver)
* **Histórico** (sempre presente)

### 5.3 Separação de dados (buckets obrigatórios)

O card armazena dados em buckets distintos, por governança e clareza:

* `sourceData` — dados vindos do ingress (readonly)
* `cardData.inputs` — inputs preenchidos por usuário
* `cardData.outputs` — outputs gerados (no MVP pode ser vazio ou gerado por ações manuais/plugins)
* `props` — propriedades gerais (ex.: labels)
* `pluginData` — dados internos de plugin

Regras de escrita no MVP:

* `sourceData`: só o ingress escreve
* `inputs`: usuário escreve
* `outputs`: sistema/plugin pode escrever (se houver)
* `props`: usuário escreve (labels)
* `pluginData`: plugin escreve

---

## 6) Histórico e alertas/warnings

### 6.1 Histórico obrigatório e estruturado

Todo card possui um histórico com eventos estruturados. Exemplos de eventos:

* card criado (manual ou via ingress)
* payload recebido/atualizado
* campo input alterado
* labels alteradas
* card movido de coluna
* plugin executado
* conector webhook executado
* warnings (template variável inexistente, ausência de ID externo, etc.)

Cada evento deve ter pelo menos:

* `type`
* `summary` (legível)
* `payload` (detalhado quando aplicável)
* `createdAt`
* `createdBy` (usuário/sistema)

### 6.2 Política de warnings (decisão final)

* Warnings **não bloqueiam** o fluxo.
* Warnings **sempre registram histórico** com detalhes do ocorrido.
* Quando aplicável, o sistema **insere `null`** como fallback para manter o processo e o JSON válidos.
* O histórico deve exibir **qual variável/campo** causou o warning e (se possível) o objeto/trecho relacionado.

---

## 7) CardType: “contrato” do card (campos dinâmicos e UI configurável)

### 7.1 Definição

CardType define como o card é exibido e quais campos existem no modal e no preview.

O CardType é configurável via UI (não exigindo edição manual de JSON), mas o sistema pode armazenar internamente uma definição baseada em JSON Schema (ou modelo equivalente).

### 7.2 Fields do CardType

Cada Field define:

* `label`
* `type`: `string | number | date | boolean | enum | object | array`
* `mode`: `editable | readonly`
* `bindingRef` (onde lê e/ou escreve)
* (opcional) formatação: moeda/unidade/data
* se aparece no preview (card fechado)
* se aparece no modal

### 7.3 BindingRef suportado

* `source.*` → `sourceData` (readonly)
* `inputs.*` → `cardData.inputs`
* `outputs.*` → `cardData.outputs`
* `props.*` → `props` (labels, etc.)
* `system.*` → metadados (id, datas)
* `pluginData.<pluginKey>.*` → dados do plugin

### 7.4 Exibição de object/array

* Pode exibir `object` e `array` no modal.
* Deve exibir tudo que estiver marcado para exibir.
* UI deve mostrar estrutura indentada (dentado).

---

## 8) Plugins do card (hardcoded no código + registro no banco)

### 8.1 Conceito

Plugin é um componente visual dentro do card (modal), associado ao CardType. Exemplos futuros: videoconferência, formulário avançado, etc.

No MVP, a estrutura deve existir para evoluir, mesmo que poucos plugins existam.

### 8.2 Dupla existência: código e banco

* **No código**: o plugin existe como componente implementado (hardcoded).
* **No banco**: existe um registro do plugin para governança e para aparecer nas telas de configuração.

### 8.3 Registro de Plugin (entidade)

Campos típicos:

* `pluginKey` (identificador único)
* `displayName`
* `description`
* `version`
* `status`: `active|inactive`
* (opcional) `capabilities` (se expõe ações, se precisa de permissões, etc.)

### 8.4 Regras de execução

* Se o plugin estiver registrado mas não existir no código (ou incompatível):

  * o card não quebra
  * o modal exibe um “placeholder” de plugin indisponível
  * registra evento no histórico (erro/warning)

---

## 9) Fonte de Entrada (IngressSource): recebendo objetos externos

### 9.1 Conceito

IngressSource é a configuração que permite que um sistema externo envie um objeto/evento e isso gere um card no board.

### 9.2 O que precisa ser configurável no IngressSource

* Board associado
* `alias` da fonte (ex.: `telemetria`) — usado também em templates (`{{$telemetria.json...}}`)
* Schema do payload externo (para validação/entendimento)
* Mapping payload → `sourceData`
* **Opcional**: definição de qual campo do payload é o “ID do objeto externo” (para suportar atualização quando existir)

### 9.3 “ID do objeto externo” (opcional, não obrigatório)

Você determinou que:

* não faz sentido exigir ID primário sempre
* se houver um campo que identifica o objeto externo, ele pode ser mapeado

Como fica:

* IngressSource pode ter `externalObjectIdPath` (ex.: `$.id` ou `$.evento.id`)
* Se esse valor estiver presente, o sistema pode usar para tentar “atualizar” um card existente
* Se estiver ausente, **não tem problema**: cria card normalmente

### 9.4 Regras de create/update (comportamento final)

Quando chega um evento para um IngressSource:

1. O sistema registra no histórico do card (ou em log sistêmico se for criação) que um evento chegou.
2. Se `externalObjectIdPath` estiver configurado **e** o valor existir no payload:

   * gera uma chave interna (ex.: `idempotencyKey = ingressKey + ":" + externalIdValue`)
   * se existir card com essa chave no board → atualiza `sourceData` desse card
   * se não existir → cria card novo com essa chave
3. Se não há `externalObjectIdPath` configurado **ou** o valor não veio:

   * cria card novo (sem idempotência)
   * registra no histórico/log um evento informativo/warning (conforme você preferir, mas sempre rastreável)

> Importante: em nenhum caso o sistema rejeita por “falta de ID”. Ele segue e registra.

---

## 10) Integração de saída: Webhook genérico (MVP)

Mesmo sem automações no MVP, o webhook é útil como **ação manual** (disparada por usuário com permissão) e como base para automações no MVP2.

### 10.1 Onde o webhook aparece no MVP

No card (modal), pode existir uma seção **“Ações”** (ou similar), visível por permissão, permitindo:

* selecionar um conector webhook configurado
* executar manualmente (por exemplo: “Enviar para BI”, “Notificar sistema X”, etc.)

Isso evita “motor de automação” agora, mas permite saída controlada.

### 10.2 Configuração do conector

O conector webhook deve permitir configurar:

* URL
* método HTTP (GET/POST/PUT/PATCH/DELETE)
* headers
* autenticação simples (o básico)
* body (quando aplicável)

### 10.3 Body com template e variáveis (definição final)

O body suporta template com variáveis vindas de:

* payload do ingress: `{{$<alias>.json...}}`

  * exemplo: `{{$telemetria.json.nome}}`
* dados do card:

  * `{{$input...}}` (inputs)
  * `{{$output...}}` (outputs)
  * `{{$props...}}` (props)
  * `{{$system...}}` (metadados)

Exemplos:

**Vindo do ingress**

```json
{ "nome": "{{$telemetria.json.nome}}" }
```

**Vindo do card**

```json
{ "nome": "{{$input.nome}}", "status": "{{$input.status}}" }
```

**Misturando**

```json
{
  "cardId": "{{$system.cardId}}",
  "placa": "{{$telemetria.json.veiculo.placa}}",
  "labels": "{{$props.labels}}",
  "decisao": "{{$input.decisao}}"
}
```

### 10.4 Tipos sem aspas (number/boolean)

Se o placeholder for usado **sem aspas**, deve permitir tipos nativos:

```json
{ "ativo": {{$input.ativo}}, "km": {{$telemetria.json.km}} }
```

Se estiver entre aspas, vira string:

```json
{ "km": "{{$telemetria.json.km}}" }
```

### 10.5 Variável inexistente: não bloqueia, insere null, registra histórico

Se uma variável não existir:

* o sistema substitui por `null`
* registra evento de warning no histórico do card com:

  * variável faltante
  * conector usado
  * timestamp
  * trecho do template/body e/ou contexto do card
* não bloqueia o fluxo e não impede o usuário de continuar operando

---

## 11) Kanban: performance, paginação e ordenação (MVP)

### 11.1 Paginação por coluna (obrigatório)

* Cada coluna carrega cards de forma independente (lazy load).
* Pode ser rolagem infinita por coluna.
* A coluna pode exibir contadores (total e carregados).

### 11.2 Ordenação simples (no lugar onde o usuário solta)

* A ordenação é a posição que o usuário definiu com drag & drop.
* Se o usuário inserir entre dois cards, persiste aquela posição.

(Não precisamos sofisticar além disso no MVP.)

---

## 12) Labels (etiquetas) por board

* Todo card pode ter labels.
* As labels são **segregadas por board** (contexto do processo).
* Labels são configuráveis via board (engrenagem) ou área admin.

---

## 13) Administração e cadastros (ponta a ponta)

Você pediu explicitamente: “nada pode ficar subentendido”. Então, abaixo está o conjunto de CRUDs e telas necessários para configurar e operar o sistema.

### 13.1 Cadastros estruturais

**Módulos**

* listar
* criar
* editar
* excluir

**Árvore do módulo**

* criar nó
* renomear
* mover (reorganizar)
* excluir nó
* associar folha → board

**Boards**

* listar
* criar
* editar
* excluir
* dentro do board: engrenagem com configurações

**Colunas do board**

* listar
* criar
* editar
* reorder
* excluir

**Labels do board**

* listar
* criar
* editar
* excluir

### 13.2 CardTypes e Fields

**CardTypes**

* listar
* criar
* editar
* excluir

**Fields do CardType**

* CRUD completo de fields
* configuração de:

  * bindingRef
  * tipo
  * editable/readonly
  * preview flags
  * validações básicas

**Associação Board → CardType**

* em algum ponto claro (engrenagem do board):

  * selecionar um CardType existente
  * (opcional) criar um novo CardType a partir dali e voltar selecionado

### 13.3 IngressSources

* listar
* criar
* editar
* excluir
* configurar:

  * alias
  * schema do payload
  * mapping → sourceData
  * externalObjectIdPath (opcional)

### 13.4 Plugins (registro no banco)

* listar plugins registrados
* registrar plugin (key, nome, versão, status)
* ativar/desativar
* (opcional) versão mínima do app/compatibilidade

### 13.5 Conectores (webhook)

* listar conectores
* criar/editar/excluir
* configurar URL/método/auth/headers/body-template
* habilitar/desabilitar por ambiente (se quiser, mas não é obrigatório no MVP)

### 13.6 Cards (operação)

* criar card manualmente dentro do board (se permitido)
* abrir/editar inputs e props
* mover colunas
* executar ação manual webhook (se permitido)
* consultar histórico

---

## 14) Login, usuário root, usuários e permissões (MVP)

### 14.1 Autenticação

* tela de login
* sessão/token

### 14.2 Root parametrizável e bootstrap

* sistema inicia com um **usuário root** configurável para primeiro acesso
* root entra e configura o restante

### 14.3 Gestão de usuários

* admin consegue:

  * criar usuário
  * editar
  * desativar
  * atribuir papéis/perfis

### 14.4 Permissões (RBAC simples)

No mínimo separar:

**Operacional**

* acessar módulos/boards permitidos
* editar inputs
* mover cards
* aplicar labels
* ver histórico

**Admin**

* tudo do operacional
* CRUD de módulos/árvore/boards/colunas/labels
* CRUD de CardTypes/Fields
* CRUD de IngressSources
* CRUD de Plugins (registro)
* CRUD de Conectores (webhook)
* CRUD de Usuários/Permissões

> Se quiser um perfil “Gestor” separado, ele pode ser um meio-termo, mas no MVP você pode começar só com Operacional/Admin.

---

## 15) Telas e rotas sugeridas (coerentes com a jornada)

### Operação

* `/login`
* `/modules` (listagem)
* `/modules/:moduleId` (árvore esquerda + área direita)
* `/boards/:boardId?view=kanban` (kanban na área direita)
* `/boards/:boardId?card=:cardId` (abre modal do card)

### Administração

* `/admin/modules`
* `/admin/boards`
* `/admin/card-types`
* `/admin/ingress-sources`
* `/admin/plugins`
* `/admin/connectors`
* `/admin/users`

---

## 16) Escopo do MVP e o que fica fora (para não inflar)

### MVP inclui

* login + root + RBAC simples
* módulos + árvore + boards
* colunas/labels configuráveis
* CardType configurável (fields + preview + plugins)
* cards com buckets separados + histórico estruturado
* ingestão via IngressSource com:

  * schema/mapping
  * ID externo opcional para update
  * create sempre quando ID não existir
* paginação por coluna (lazy load)
* webhook genérico configurável com template e variáveis
* execução manual do webhook (ação no card, por permissão)

### Fora do MVP (MVP2)

* motor completo de automações (gatilho/condição/ação)
* schedules (criar/mover cards automaticamente)
* conectores avançados além do webhook (WhatsApp/Email etc.)
* validações avançadas de schema/condições complexas

---

## 17) Regras de negócio resumidas (para implementação)

1. **Card sempre tem CardType**; board sempre tem 1 CardType.
2. `sourceData` é readonly; só ingress atualiza.
3. Inputs e props são editáveis conforme permissão; outputs são readonly por padrão.
4. Histórico registra tudo (inclui warnings).
5. Ingress:

   * se houver `externalObjectIdPath` e valor existir: pode atualizar card existente
   * se não houver/valor não existir: cria card novo e registra rastreabilidade
6. Webhook:

   * body suporta variáveis `{{$alias.json...}}`, `{{$input...}}`, `{{$output...}}`, `{{$props...}}`, `{{$system...}}`
   * variável inexistente vira `null` + warning no histórico, sem bloquear
   * tipos nativos funcionam sem aspas
